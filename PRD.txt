# 1. Общее описание

**Название проекта:** Skills‑Master
**Цель:** Простой веб‑сервис (админка), который:

1. Принимает на вход CSV со скиллами и отметками (`X`).
2. Через OpenRouter вызывает LLM, чтобы по каждому отмеченному скиллу сгенерировать подробный блок (skills.json).
3. Показывает результат в удобном интерфейсе с «расклапами» (accordion / tree‑view).
4. Позволяет скачать итоговый `skills.json`.

Приоритетный хостинг — **Vercel** (Next.js). Если по каким‑то причинам Vercel использовать нельзя, альтернативный вариант — **Railway** (Node.js‑сервер).

---

# 2. Контекст и мотивы

Существуют:

* CSV‑матрицы компетенций (сквозные компетенции) — короткие формулировки скиллов в строках.
* По столбцам (например, `A`) проставлены `X` — какие скиллы входят в конкретный профиль (специалист/трек).

Задача Study‑Master — по этим формулировкам сделать **богатый структурированный JSON** (`skills.json`), где:

* каждый скилл подробно расписан;
* внизу есть сводный блок про специалиста, который владеет этим набором скиллов.

Сейчас это делается «вручную через чат». Админка должна:

* стандартизировать входной формат;
* избавить от ручных промптов;
* дать наглядный просмотр результата.

---

# 3. Целевая аудитория

**Роль:** методист / автор программы / внутренний админ Study‑Master.

Навыки:

* базовое владение CSV / таблицами;
* понимает, что такое LLM, OpenRouter и модели, но не обязательно девелопер.

---

# 4. Входные и выходные данные

## 4.1. Входной CSV

Канонический формат (минимальный):

* **Колонка 1** — текст скилла

  * пример заголовка: `Формулировка компетенции (проект)` или `skill`;
* **Колонка 2** — столбец профиля (например, `A`), где:

  * `X` — скилл включён в профиль;
  * пусто — игнорируем.

Пример:

```csv
Формулировка компетенции (проект),A
Способен осуществлять предварительный анализ данных и применять методы сбора и разметки данных,X
Способен применять знания об истории развития и трендах современного ИИ,
Способен применять и (или) разрабатывать алгоритмы, методы и технологии обработки естественного языка,X
...
```

Требования:

* Первая строка — **заголовок колонок**.
* Кодировка UTF‑8.
* Разделитель — запятая `,` или `;` (нужно автоопределение).
* Максимальный размер файла — например, 2–5 МБ (конфигурируемо).

На старте поддерживаем **одну колонку профиля** (`A`). В будущем можно добавить выбор столбца (`A/B/C/...`).

## 4.2. Выходной `skills.json`

Структура (высокоуровнево):

```ts
type SkillProject = {
  title: string;
  description: string;
  requirements: string[];
  deliverables: string[];
  focusSkills: string[];
};

type Skill = {
  id: string;                // slug/хэш от текста
  source: {
    text: string;            // исходная формулировка из CSV
    profileColumn: string;   // например, "A"
  };

  // 1. нейминг скилла
  name: string;

  // 2. короткое описание
  summary: string;

  // 3. подробное описание (тезисы)
  details: string[];         // 5–10 буллетов

  // 4. базовый список технологий
  coreTechnologies: string[]; // 5–10 позиций

  // 5. вопросы для проверки (10 шт)
  checkQuestions: string[];   // длина = 10

  // 6. проект под этот скилл
  project: SkillProject;
};

type SpecialistProfile = {
  title: string;  // как назовём профиль (можно задать при генерации)

  marketNames: {
    us: string[]; // как называют на рынке США
    ru: string[]; // как называют в РФ
    de: string[]; // как называют в Германии
  };

  avgSalary: {
    usdYear: number | null;
    rubMonth: number | null;
    eurYearDe: number | null;
    note?: string;  // дисклеймер про условность оценок
  };

  typicalProjects: string[];        // 5–10 примеров задач/проектов
  mustAnswerQuestions: string[];    // 10–20 сборных вопросов по профилю

  testProject: {
    title: string;
    description: string;
    requirements: string[];
  };
};

type SkillsJson = {
  meta: {
    profileId: string;      // "A" (колонка)
    profileName: string;    // человекочитаемое название профиля (задано пользователем)
    sourceFile: string;     // имя загруженного CSV
    generatedAt: string;    // ISO‑дата
    model: string;          // id модели OpenRouter
  };
  skills: Skill[];
  specialistProfile: SpecialistProfile;
};
```

---

# 5. Основные пользовательские сценарии

## 5.1. Сценарий 1: Загрузка и генерация

1. Админ открывает страницу админки `/admin`.
2. Видит форму:

   * поле выбора файла CSV;
   * выпадающий список моделей OpenRouter;
   * поле для имени профиля (`profileName`, например «AI Practicum»);
   * кнопка «Сгенерировать skills.json».
3. Админ выбирает:

   * CSV с компетенциями;
   * модель (например, `openrouter/…`),
   * вводит человекочитаемое имя профиля.
4. Нажимает «Сгенерировать».
5. Система:

   * парсит CSV;
   * извлекает все строки, где во второй колонке стоит `X`;
   * считает, сколько скиллов будет расписано (например, 12);
   * последовательно (или батчами) вызывает LLM для каждого скилла;
   * после завершения — вызывает LLM для блока `specialistProfile`.
6. Пользователь видит индикатор прогресса (например, «5/12 скиллов обработано»).

Результат:

* На фронте появляется панель с «расклапами» по каждому скиллу + блок профиля.
* Появляется кнопка «Скачать JSON».

## 5.2. Сценарий 2: Просмотр результатов

После генерации:

* Слева — список скиллов (типа навигации):

  * просто список `name`, при клике — скролл к нужному блоку.
* Справа — аккордеоны по каждому скиллу:

  Заголовок аккордеона:

  * `name` (сгенерированный нейминг);
  * подзаголовок — короткое summary;
  * иконка «расхлопа».

  Внутри (при открытии):

  * исходный текст (`source.text`);
  * список `details` (тезисы);
  * список `coreTechnologies`;
  * блок с 10 вопросами (`checkQuestions`);
  * блок с описанием проекта (`project`).

Внизу отдельный аккордеон:

* **«Профиль специалиста»**:

  * `title`,
  * `marketNames`,
  * `avgSalary`,
  * `typicalProjects`,
  * `mustAnswerQuestions`,
  * `testProject`.

## 5.3. Сценарий 3: Скачивание результата

* На верхней панели / справа сверху есть кнопка:

  * «Скачать `skills.json`».
* При нажатии:

  * браузер скачивает файл `skills_<profileId>_<timestamp>.json` с содержимым `SkillsJson`.

---

# 6. Функциональные требования

## 6.1. Загрузка и парсинг CSV

* FR‑1: Поддержка загрузки CSV через форму (type `file` / drag&drop).
* FR‑2: Валидация:

  * файл не пустой;
  * есть минимум 2 колонки;
  * хотя бы один скилл с `X`.
* FR‑3: Автоопределение разделителя (`,` / `;`).
* FR‑4: Сохранение имени файла в `meta.sourceFile`.
* FR‑5: Обработка первой строки как заголовок (не скилл).

## 6.2. Выбор модели через OpenRouter

* FR‑6: В настройках (на UI) пользователь выбирает модель из списка:

  * список моделей можно захардкодить в конфиге (например 3–5 штук).
* FR‑7: На бэкенд передаётся `modelId`, который используется при запросе к OpenRouter.
* FR‑8: Секретный ключ OpenRouter хранится в переменной окружения (`OPENROUTER_API_KEY`).

## 6.3. Генерация по скиллам

* FR‑9: Для каждого выбранного скилла создаётся одно обращение к LLM с промптом примерно:

  * Вход: исходный текст компетенции (из CSV) + контекст о том, что это за профиль/роль (из `profileName`).
  * Выход: JSON c полями `name`, `summary`, `details[]`, `coreTechnologies[]`, `checkQuestions[10]`, `project{...}`.

* FR‑10: Результат валидируется по JSON‑схеме:

  * гарантируем 10 вопросов;
  * массивы не пустые;
  * строки не пустые.

* FR‑11: При ошибке конкретного скилла:

  * показываем пользователю, для какого скилла произошла ошибка;
  * не валим всю генерацию (по возможности), но в первой версии можно сделать проще — если ошибка, то генерация фейлится целиком с понятным сообщением.

## 6.4. Генерация профиля специалиста

* FR‑12: После генерации всех `skills` выполняется отдельный запрос к LLM для получения `specialistProfile`.

  * Вход: `profileName` + список `Skill.name`/`Skill.summary`.
  * Выход: объект `SpecialistProfile`.
* FR‑13: Заполняем блок `meta` (profileId, profileName, model, timestamp).
* FR‑14: Собираем финальный объект `SkillsJson`.

## 6.5. Отображение результатов

* FR‑15: Интерфейс «расклапов»:

  * список скиллов с возможностью открыть/закрыть подробности;
  * один общий блок для профиля.
* FR‑16: Отображение JSON‑структуры в человекочитаемом виде, не просто raw JSON.
* FR‑17: Дополнительно опционально — вкладка «Raw JSON» с отображением `skills.json` как prettified JSON.

## 6.6. Скачивание JSON

* FR‑18: Кнопка «Скачать JSON»:

  * триггерит генерацию файла на клиенте или отдачу файла бэкендом;
  * имя файла: `skills_<profileId>_<YYYYMMDD_HHMM>.json`.

---

# 7. Нефункциональные требования

* NFR‑1: Развёртывание на Vercel (приоритет) или Railway (fallback).
* NFR‑2: Время генерации:

  * при ~10–20 скиллах — до 1–2 минут (зависит от модели; это ориентир, не жёсткий SLA).
* NFR‑3: Сервис не хранит чувствительные данные:

  * CSV и результаты можно держать только в памяти на время сессии;
  * при перезагрузке страницы данные теряются (на первом этапе это допустимо).
* NFR‑4: Локализация:

  * интерфейс на русском,
  * скиллы генерируются на русском (если текст компетенций на русском).
* NFR‑5: Логирование:

  * логировать ошибки парсинга CSV и ошибки OpenRouter;
  * не логировать содержимое скиллов целиком в проде (или сделать это конфигурируемым).

---

# 8. Техническая архитектура

## 8.1. Технологический стек (предпочтительный)

**Вариант 1: Vercel (предпочтительно)**

* Frontend + Backend: **Next.js (App Router)**

  * UI — React (TypeScript).
  * API‑роут `/api/generate` — серверная функция Next.js.
* Запросы к OpenRouter — из серверного кода Next.js.

**Вариант 2: Railway (fallback)**

* Backend: Node.js + Express/Fastify (TypeScript).
* Frontend: React SPA (Vite / CRA), собранный и раздаваемый с того же сервера или через статический хостинг.
* API `/api/generate` реализован в Express/Fastify.

## 8.2. Основные компоненты

1. **CSVParser**

   * На вход: файл CSV (buffer / string).
   * На выход: массив `{ id, text, selected, profileColumn }`.
   * Реализует:

     * определение разделителя;
     * пропуск заголовка;
     * фильтрацию по `X`.

2. **SkillGenerator (LLM‑обёртка)**

   * На вход: `RawSkill`, `profileName`, `modelId`.
   * Делает запрос к OpenRouter.
   * Возвращает `Skill`.

3. **SpecialistProfileBuilder**

   * На вход: `profileName`, массив `skills`.
   * Возвращает `SpecialistProfile`.

4. **SkillsJsonBuilder**

   * На вход: meta + skills + profile.
   * На выход: финальный `SkillsJson`.

5. **UI‑слой**

   * Компонент загрузки файла и выбора модели.
   * Компонент отображения прогресса.
   * Компонент аккордеонов по скиллам.
   * Кнопка скачивания.

## 8.3. Интеграция с OpenRouter

* ENV:

  * `OPENROUTER_API_KEY` — ключ.
  * `OPENROUTER_API_BASE` — при необходимости (по умолчанию стандартный base URL).
* Backend‑код:

  * делает HTTP POST в OpenRouter с параметрами:

    * `model`: из UI;
    * `messages` или `prompt`: с промптом для генерации;
    * `temperature`: настраиваемый (можно задать фиксированный).
* Важно: все запросы к OpenRouter — только **на сервере**, не из браузера.

---

# 9. UI/UX‑описание

## 9.1. Главный экран `/admin`

**Структура:**

* Хедер:

  * Название: «Study‑Master Skills Admin».
  * Короткий сабтайтл: «Загрузка CSV → генерация skills.json».
* Левая панель / верхний блок:

  * Блок «Загрузка CSV»:

    * кнопка выбора файла;
    * подпись с названием выбранного файла;
    * небольшая подсказка по формату CSV.
  * Блок «Настройки генерации»:

    * select «Модель OpenRouter» (список 3–5 моделей);
    * input «Название профиля» (строка).
  * Кнопка «Сгенерировать skills.json».
* Правая панель / нижний блок:

  * В состоянии «пока ничего нет» — заглушка с текстом «Загрузите CSV и запустите генерацию».
  * В процессе — индикатор прогресса:

    * «Обработано X из N скиллов».
  * После завершения:

    * кнопка «Скачать JSON»;
    * слева — список скиллов;
    * справа — аккордеоны с подробностями.

## 9.2. Аккордеон скилла

В свернутом состоянии:

* `name` — жирным;
* `summary` — серым мелким;
* индикатор `id` (иконка/маленький тег, не обязательно).

В раскрытом:

1. Блок «Исходная формулировка» (`source.text`).
2. Блок «Что нужно знать/уметь» (`details[]`).
3. Блок «Технологии» (`coreTechnologies[]`).
4. Блок «Вопросы для самопроверки» (`checkQuestions[]`).
5. Блок «Проект для проверки скилла» (`project`).

## 9.3. Блок профиля

Отдельный аккордеон «Профиль специалиста»:

* Сверху:

  * `title`;
  * `marketNames` (в виде таблички/списка).
* Далее:

  * `avgSalary` (с подписью‑дисклеймером из `note`);
  * `typicalProjects`;
  * `mustAnswerQuestions`;
  * `testProject`.

---

# 10. Ошибки и обработка

* Ошибка парсинга CSV:

  * UX: красный баннер с описанием («Не удалось прочитать CSV, проверьте формат»).
* Нет ни одного `X`:

  * UX: предупреждение «В выбранной колонке нет ни одной отметки, генерировать нечего».
* Ошибка OpenRouter (нет ключа/лимит/ошибка сети):

  * UX: сообщение «Не удалось обратиться к модели. Проверьте ключ OpenRouter и повторите попытку».
* Если один из запросов к модели вернул некорректный JSON:

  * MVP‑вариант: прерываем генерацию и показываем, на каком скилле всё сломалось.

---

# 11. Ограничения и допущения

* Одновременная работа с одним профилем (одним CSV) — без истории.
* Аутентификация на первом этапе может отсутствовать (админка для внутреннего пользования).
* Все сгенерированные данные хранятся только в памяти на текущую сессию (без БД).
* Зарплатные вилки в `avgSalary` могут быть:

  * либо `null` + дисклеймер;
  * либо примерные числа, если позже решим подтягивать где‑то извне (в этом PRD — опционально).

---

# 12. Возможные расширения (не в MVP)

* Поддержка нескольких профилей в одном CSV (колонки A/B/C), выбор нужного столбца в UI.
* Ручное редактирование сгенерированных скиллов прямо в админке.
* Сохранение версий `skills.json` в базу (история генераций).
* Экспорт не только в JSON, но и в Markdown/HTML.